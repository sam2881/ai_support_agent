import json
import logging
import os
from typing import Dict, Any, List

from agent.workflows.agents.airflow_agent import AirflowAgent
from agent.workflows.agents.devops_agent import DevOpsAgent
from agent.workflows.agents.access_agent import AccessAgent
from agent.clients.github_client import GitHubClient
from agent.utils.queue_utils import ApprovalQueue # Import the ApprovalQueue class
from agent.workflows.config import settings

# Configure logging for this module
logger = logging.getLogger(__name__)

class ApprovalProcessor:
    def __init__(self):
        """
        Initializes the ApprovalProcessor with instances of all agents
        and clients necessary for execution.
        """
        self.airflow_agent = AirflowAgent()
        self.devops_agent = DevOpsAgent()
        self.access_agent = AccessAgent()
        self.github = GitHubClient() # Used for commenting on issues
        self.approval_queue = ApprovalQueue() # Use the ApprovalQueue class

        # Map agent names to their instances for dynamic dispatch
        self.agents = {
            "airflow": self.airflow_agent,
            "devops": self.devops_agent,
            "access": self.access_agent,
        }

    def process_approvals(self):
        """
        Reads approved items from the approval queue and attempts to execute
        the proposed remediations using the appropriate agent.
        """
        logger.info("üöÄ Starting Approval Processor...")
        
        # Retrieve all approved items from the queue
        approved_items = self.approval_queue.get_approved_items()

        if not approved_items:
            logger.info("üì≠ No approved items found in the queue.")
            return

        logger.info(f"Found {len(approved_items)} approved item(s) to process.")
        
        processed_successfully: List[Dict[str, Any]] = []
        
        for item in approved_items:
            issue_number = item.get("issue_number")
            agent_name = item.get("agent")
            payload = item.get("payload", {})
            queue_item_key = item.get("key") # The unique key generated by ApprovalQueue

            if not issue_number or not agent_name:
                logger.error(f"‚ùå Skipping invalid approval item: {item}. Missing issue_number or agent name.")
                continue

            logger.info(f"‚ú® Processing approval for Issue #{issue_number} by agent '{agent_name}'.")

            agent_instance = self.agents.get(agent_name)
            if not agent_instance:
                logger.warning(f"‚ö†Ô∏è No agent found for category '{agent_name}'. Skipping execution for Issue #{issue_number}.")
                comment = (
                    f"‚ö†Ô∏è Approval Processor: Cannot execute action for agent '{agent_name}'. "
                    f"Agent not recognized or implemented."
                )
                self.github.add_comment(issue_number, comment)
                continue

            execution_result = {"status": "failed", "message": "Unknown error during execution."}
            try:
                if agent_name == "airflow":
                    dag_id = payload.get("dag_id")
                    task_id = payload.get("task_id")
                    dag_run_id = payload.get("dag_run_id", "")
                    
                    if not dag_id or not task_id:
                        comment = f"‚ùå Airflow execution failed: Missing DAG ID or Task ID in payload for Issue #{issue_number}."
                        logger.error(comment)
                        self.github.add_comment(issue_number, comment)
                        continue

                    execution_result = agent_instance.execute_remediation(
                        issue_number=issue_number,
                        dag_id=dag_id,
                        task_id=task_id,
                        dag_run_id=dag_run_id
                    )
                elif agent_name == "devops":
                    target_component = payload.get("target_component")
                    proposed_action = payload.get("proposed_action")

                    if not target_component or not proposed_action:
                        comment = f"‚ùå DevOps execution failed: Missing target component or proposed action in payload for Issue #{issue_number}."
                        logger.error(comment)
                        self.github.add_comment(issue_number, comment)
                        continue

                    execution_result = agent_instance.execute_remediation(
                        issue_number=issue_number,
                        target_component=target_component,
                        proposed_action=proposed_action
                    )
                elif agent_name == "access":
                    target_user_group = payload.get("target_user_group")
                    resource = payload.get("resource")
                    proposed_action = payload.get("proposed_action")

                    if not target_user_group or not resource or not proposed_action:
                        comment = f"‚ùå Access execution failed: Missing user/group, resource, or proposed action in payload for Issue #{issue_number}."
                        logger.error(comment)
                        self.github.add_comment(issue_number, comment)
                        continue

                    execution_result = agent_instance.execute_remediation(
                        issue_number=issue_number,
                        target_user_group=target_user_group,
                        resource=resource,
                        proposed_action=proposed_action
                    )
                
                logger.info(f"Execution result for Issue #{issue_number} ({agent_name}): {execution_result.get('status')} - {execution_result.get('message')}")

                # If execution was successful, mark the item as processed in the queue
                if execution_result.get("status") == "resolved" or execution_result.get("auto_approved"):
                    processed_successfully.append(item)
                    logger.info(f"‚úÖ Issue #{issue_number} remediation successfully executed and marked as processed.")
                    
                    # Optionally close the GitHub issue if the remediation was successful
                    try:
                        self.github.close_issue(issue_number, execution_result.get('message', 'Remediation completed.'))
                        logger.info(f"GitHub Issue #{issue_number} closed.")
                    except Exception as gh_e:
                        logger.error(f"‚ùå Failed to close GitHub Issue #{issue_number}: {gh_e}", exc_info=True)
                else:
                    logger.warning(f"‚ö†Ô∏è Issue #{issue_number} remediation failed or requires further manual action.")

            except Exception as e:
                logger.error(f"‚ùå Error executing remediation for Issue #{issue_number} by agent '{agent_name}': {e}", exc_info=True)
                comment = (
                    f"‚ùå Approval Processor: An unexpected error occurred while executing the remediation "
                    f"for Issue #{issue_number} with agent '{agent_name}'. Error: `{e}`"
                )
                self.github.add_comment(issue_number, comment)
        
        # After attempting all executions, mark the successfully processed items
        if processed_successfully:
            for item_to_mark in processed_successfully:
                self.approval_queue.mark_as_processed(item_to_mark.get("issue_number"), item_to_mark.get("key"))
            logger.info(f"Total {len(processed_successfully)} approved items successfully processed and removed from queue.")
        else:
            logger.info("No items were successfully processed in this run.")

        logger.info("üèÅ Approval Processor finished.")

# Entry point for running the processor (e.g., via a cron job)
if __name__ == "__main__":
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - [%(name)s] - %(message)s'
    )
    processor = ApprovalProcessor()
    processor.process_approvals()